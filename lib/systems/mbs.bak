#ifndef RPC_MBS_H
#define RPC_MBS_H

#include "body3d.h"
#include "mbsmanifold.h"
#include <limits>
#include <iostream>
#include <utility>
#include "function.h"

namespace rpc {
  
  using namespace std;
  using namespace Eigen;


  class Joint {
  public:
    Joint();

    Vector6d a;    ///< axis

    Matrix4d gp;   ///< from parent to joint
    Matrix4d gpi;  ///< from parent to joint inverse

    Matrix4d gc;   ///< from child to joint
    Matrix4d gci;  ///< from child to joint inverse

    Vector6d Jrs;    ///< relative jacobians (nb-1) vector =Ad(gc)a
  };

  /**
   * Control system modeled as an underactuated rigid body in 3d. It is meant as 
   * a base class for implementing specific vehicles. 
   *
   * The discrete mechanics is
   * based on an implicit symplectic variational integrator which is second-order accurate
   * and momentum-balance preserving. Regularity is guaranteed by choosing a time-step 
   * which does not jump out of the convex region around the initial guess from the previous
   * dynamics iteration.
   *
   * Author: Marin Kobilarov marin(at)jhu.edu
   */
  template <int nb, int c> 
    class Mbs : public System< MbsState<nb>, MBS_DIM(nb), c> {
    
    typedef Matrix<double, c, 1> Vectorcd;
    typedef Matrix<double, c, c> Matrixcd;
    typedef Matrix<double, 6, c> Matrix6xcd;
    typedef Matrix<double, MBS_DIM(nb), c> Matrixncd;
    typedef Matrix<double, MBS_DIM(nb), MBS_DIM(nb)> Matrixnd;
    
    typedef Matrix<double, 6 + nb - 1, 1> Vectormd;
    //    typedef pair<Matrix4d, Vector<double, 2*m - 6> > MbsState;

  public:
    
    Mbs();

    void Init();
    
    double F(double t, MbsState<nb> &xb, const MbsState<nb> &xa, 
             const Vectorcd &u, double h,
             Matrixnd *A = 0, Matrixncd *B = 0);
    
    void ID(Vectormd &f,
            double t, const MbsState<nb> &xb, const MbsState<nb> &xa,
            const Vectorcd &u, double h);

    void FK(MbsState<nb> &x);

    void KStep(MbsState<nb> &xb, const MbsState<nb> &xa, double h);

    void Mass(Matrix<double, nb + 5, nb + 5> &M, const MbsState<nb> &x);

    virtual void Force(Vectormd &f, double t, const MbsState<nb> &x, const Vectorcd &u) = 0;


    vector<Body3d<>> links;    ///< link params
    
    vector<Joint> joints;

    //    vector<Vector6d> joints; ///< joint screws (nb-1) vector

    vector<Matrix6d> Ips;    ///< A'*I*A (nb) vector
    vector<Matrix4d> g0s;    ///< offsets (nb) vector
    vector<Matrix4d> g0is;   ///< their inverses (nb) vector

    vector<int> pis;          ///< parent index
    vector<vector<int> > cs;  ///< child lists

    SE3 &se3;

    /*
    class Fxb : public Function<MbsState, 12, 6> {
    public:
    Fxb(Mbs<c> &sys) :
      Function(MbsManifold::Instance()), sys(sys) {        
      }
      
      void F(Vector6d &f, const MbsState &xb) {
        sys.ID(f, t, xb, xa, u, h);
      }
      
      Mbs<c> &sys;
      
      double t;
      MbsState xa;
      Vectorcd u;
      double h;
    };    
    */
  };
  
  
  template <int nb, int c> 
    Mbs<nb, c>::Mbs() : 
    links(nb),
    joints(nb-1), Jrs(nb-1),
    Ips(nb), g0s(nb), g0is(nb), pis(nb), cs(nb), se3(SE3::Instance()) {

  }
  
  
  template <int nb, int c> 
    void Mbs<nb, c>::Init() {
    
    Matrix6d A;
    
    for (int i = 0; i < nb; ++i) {
      se3.inv(g0is[i], g0s[i]);

      se3.Ad(A, g0is[i]);
      Ips[i] = A.transpose()*links[i].I.asDiagonal()*A;
      
      if (i > 0) {
        Jrs[i-1] = A*joints[i-1];
      }
    }

    pis[0] = -1;

    for (int i= nb-1; i > 0; --i)
      cs[pis[i]].push_back(i);
    
  }
  


  template <int nb, int c> 
    double Mbs<nb, c>::F(double t, MbsState<nb> &xb, const MbsState<nb> &xa, 
                         const Matrix<double, c, 1> &u, double h,
                         Matrix<double, MBS_DIM(nb), MBS_DIM(nb)> *A, Matrix<double, MBS_DIM(nb), c> *B) {
  
    Matrix<double, nb + 5, nb + 5> M;
    // assume that FK(xa) was generated
    Mass(M, xa);
    
    Matrix<double, nb + 5, 1> a;  // accelerations
    Matrix<double, nb + 5, 1> f;  // bias forces

    // compute bias
    xb.dr = xa.dr;
    xb.vs[0] = xa.vs[0];
    KStep(xb, xa, h);

    ID(f, t, xb, xa, u, h);

    //    f.setZero();

    // compute acceleration
    LLT<Matrix<double, nb + 5, nb + 5> > llt;
    llt.compute(M);    
    if (llt.info() == Eigen::Success) {
      a = -llt.solve(f);
    } else {
      cout << "[W] Mbs::F Mass matrix not positive definite!" << endl;
      return 0;
    }
      
    //    a = -M.inverse()*f;
  
    // update state
    xb.vs[0] += h*a.head(6);

    xb.dr += h*a.tail(nb-1);
    
    KStep(xb, xa, h);
  }

  template <int nb, int c> 
    void Mbs<nb, c>::Mass(Matrix<double, nb + 5, nb + 5> &M, const MbsState<nb> &x) {
    
    vector<Matrix6d> Ics(nb);

    for (int i=0; i < nb; ++i) {
      Ics[i] = Ips[i];
    }

    for(int i = nb-1; i >=0; --i) {
      int j = pis[i];
      if (j >= 0) { // if has a parent
        Matrix6d Aij;
        Matrix4d gi;
        se3.inv(gi, x.Ms[i]);
        se3.Ad(Aij, gi*x.Ms[j]);
        Ics[j] += Aij.transpose()*Ics[i]*Aij;
      }
      
      if (i > 0) {
        Vector6d F(Ics[i]*joints[i-1]);
        M(6+i-1, 6+i-1) = joints[i-1].dot(F);
        
        j=i;
        while(pis[j] >= 0) {
          int l = pis[j];
          Matrix6d Ajl;
          Matrix4d gi;
          se3.inv(gi, x.Ms[j]);
          se3.Ad(Ajl, gi*x.Ms[l]);
          F = Ajl.transpose()*F;
          j = l;
          if (j > 0) {
            M(6+i-1, 6+j-1) = F.dot(joints[j-1]);
            M(6+j-1, 6+i-1) = M(6+i-1, 6+j-1);
          }
        }
        //        M.block<6,1>(0, 6+i-1) = F;
        //        M.block<1,6>(6+i-1, 0) = F.transpose();
        M.block(0, 6+i-1, 6, 1) = F;
        M.block(6+i-1, 0, 1, 6) = F.transpose();

      }
    }
    // M.topLeftCorner<6,6>() = Ics[0];
    M.topLeftCorner(6,6) = Ics[0];
  }

  
  template <int nb, int c> 
    void Mbs<nb, c>::FK(MbsState<nb> &x) {
    // given: x.gs[0], x.r 
    // compute: x.gs[*], x.dgs[*], x.Ms[*]

    Matrix4d dg;
    x.Ms[0].setIdentity();
    for (int i = 1; i < nb; ++i) {
      int pi = pis[i];
      se3.exp(dg, x.r[i-1]*joints[i-1]);
      x.dgs[i-1] = g0is[pi]*dg*g0s[i];
      x.Ms[i] = x.Ms[pi]*dg;
      x.gs[i] = x.gs[pi]*x.dgs[i-1];
    }
  }


  template <int nb, int c> 
    void Mbs<nb, c>::ID(Matrix<double, 6 + nb - 1, 1> &f,
                        double t, const MbsState<nb> &xb, const MbsState<nb> &xa,
                        const Matrix<double, c, 1> &u, double h) {
    vector<Vector6d> ps(nb);
    Matrix6d Da, Db;
    Matrix6d A;
    Matrix4d gi;

    for (int i = nb - 1; i >= 0; --i) {      
      const Vector6d &va = xa.vs[i];
      const Vector6d &vb = xb.vs[i];
      const Vector6d &I = links[i].I;

      //      se3.dcayinv(Db, h*vb);
      //      se3.dcayinv(Da, -h*va);
      //      ps[i] = (Db.transpose()*(I.cwiseProduct(vb)) -  Da.transpose()*(I.cwiseProduct(va)))/h;
      Vector6d mua, mub;
      se3.tln(mub, h*vb, I.cwiseProduct(vb));
      se3.tln(mua, -h*va, I.cwiseProduct(va));
      ps[i] = (mub - mua)/h;

      cout << "va=" << va << endl;
      cout << "vb=" << vb << endl;
      cout << "mua=" << mua << endl;
      cout << "mub=" << mub << endl;

      cout << "ps[" << i << "]=" << ps[i] << endl;

      for (int ci = 0; ci < cs[i].size(); ++ci) {
        
        
        int j = cs[i][ci];   // index of ci-th child of i

        cout << "CHILD: i=" << i << " j=" << j << endl;
        assert(j > 0);
        se3.inv(gi, xa.dgs[j-1]);
        se3.Ad(A, gi);
        ps[i] += A.transpose()*ps[j];
      }

      cout << "i=" << i << "ps=" << ps[i] << endl;

      if (i > 0) 
        f[6+i-1] = Jrs[i - 1].dot(ps[i]);
      else
        f.head(6) = ps[0];
    }

    Matrix<double, 6 + nb - 1, 1> fu;
    Force(fu, t, xa, u);  // compute control/external forces
    f = f - fu;
  }


  template <int nb, int c> 
    void Mbs<nb, c>::KStep(MbsState<nb> &xb, const MbsState<nb> &xa, double h) {

    // given: xa, xb.vs[0], xb.dr[*]
    // compute: xb.dgs[*], xb.gs[*],  xb.vs[*], xb.r[*]

    Matrix<double, 4, 4> dg;
    Matrix<double, 4, 4> gi;

    xb.Ms[0].setIdentity();

    for (int i = 0; i < nb; ++i) {
      if (i > 0) {
        xb.r[i-1] = xa.r[i-1] + h*xb.dr[i-1];
        
        int pi = pis[i];
        se3.inv(gi, xa.gs[i]);
        se3.exp(dg, xb.r[i-1]*joints[i-1]);
        xb.dgs[i-1] = g0is[pi]*dg*g0s[i];  // this is also in FK
        xb.Ms[i] = xb.Ms[pi]*dg;         // this is also in FK
        se3.log(xb.vs[i], gi*xb.gs[pi]*xb.dgs[i-1]);
        xb.vs[i] /= h;
      }
      se3.exp(dg, h*xb.vs[i]);
      xb.gs[i] = xa.gs[i]*dg;
    }
  }

}

#endif

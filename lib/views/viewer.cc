#include <stdio.h>#include <string.h>#include <assert.h>#include <iostream>#include <cmath>#include <unistd.h>#include "utils.h"#include "viewer.h"#include "so3.h"//#include <GL/glx.h>#ifdef HAVE_GLUI_H#include "GL/glui.h"#endifusing namespace std;using namespace gcop;using namespace Eigen;#define LIGHTX (1.0f)#define LIGHTY (0.4f)void g_viewer_reshape(int w, int h); void g_viewer_render(); void g_viewer_keyboard(unsigned char ch, int x, int y); void g_viewer_mouse(int button, int state, int x, int y); void g_viewer_motion(int x, int y); void g_viewer_idle(void);void g_timer_func(int);void g_save_frames(int);Viewer* Viewer::instance = 0;Viewer::Viewer(){  this->sphi= 45.0;  this->stheta = 30.0;  this->sx = 0;  //  this->sy = -10;  //  this->sz = -20;  this->sx = 0;  this->sy = 0;  this->sz = -10;  this->zNear = 0.0;  this->zFar = 1000.0;  this->aspect = 5.0/4.0;  this->xcam = 0;  this->ycam = 0;  this->width = 800;  this->height = 800;  this->os = 1;  this->rgb[0] = 0;  this->rgb[1] = 0;  this->rgb[2] = 0;  this->window = 0;   this->downX = 0;  this->downY = 0;  this->leftButton = 0;  this->middleButton = 0;  this->rightButton = 0;  pthread_mutex_init(&this->mut, 0);      this->instance = this;  animate = false;  animDelay = 10000;  saveFrames = 0;  frameName = 0;  saveDisplay = 0;  displayName = 0;  displayNo = 0;  saveSnapshot = 0;  // views = 0;  aqobj = gluNewQuadric();  altLight = false;  this->rgbimg = (unsigned char*)malloc(4*width*height*sizeof(double));  this->ppmimg = (unsigned char*)malloc(4*width*height*sizeof(double));}Viewer::~Viewer(){  free(ppmimg);  free(rgbimg);  free(aqobj);  views.clear();}void Viewer::SetCamera(float sphi, float stheta,                        float sx, float sy, float sz){  this->sphi = sphi;  this->stheta = stheta;  this->sx = sx;  this->sy = sy;  this->sz = sz;}void Viewer::SetCamera(const float params[5]){  SetCamera(params[0], params[1], params[2], params[3], params[4]);}void Viewer::SetMaterial( GLfloat ambientR, GLfloat ambientG, GLfloat ambientB,                           GLfloat diffuseR, GLfloat diffuseG, GLfloat diffuseB,                           GLfloat specularR, GLfloat specularG, GLfloat specularB,                          GLfloat shininess ){      GLfloat ambient[] = { ambientR, ambientG, ambientB };    GLfloat diffuse[] = { diffuseR, diffuseG, diffuseB };    GLfloat specular[] = { specularR, specularG, specularB };    glMaterialfv(GL_FRONT_AND_BACK,GL_AMBIENT,ambient);    glMaterialfv(GL_FRONT_AND_BACK,GL_DIFFUSE,diffuse);    glMaterialfv(GL_FRONT_AND_BACK,GL_SPECULAR,specular);    glMaterialf(GL_FRONT_AND_BACK,GL_SHININESS,shininess);}// sets the material color, not the light colorvoid Viewer::SetColor (float r, float g, float b, float alpha){  GLfloat light_ambient[4],light_diffuse[4],light_specular[4];  light_ambient[0] = r*0.3f;  light_ambient[1] = g*0.3f;  light_ambient[2] = b*0.3f;  light_ambient[3] = alpha;  light_diffuse[0] = r*0.7f;  light_diffuse[1] = g*0.7f;  light_diffuse[2] = b*0.7f;  light_diffuse[3] = alpha;  light_specular[0] = r*0.2f;  light_specular[1] = g*0.2f;  light_specular[2] = b*0.2f;  light_specular[3] = alpha;  glMaterialfv (GL_FRONT_AND_BACK, GL_AMBIENT, light_ambient);  glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE, light_diffuse);  glMaterialfv (GL_FRONT_AND_BACK, GL_SPECULAR, light_specular);  glMaterialf (GL_FRONT_AND_BACK, GL_SHININESS, 50);  }voidInitViewerWindow(){  GLfloat Ambient[] = { 0.2f, 0.2f, 0.2f, 1.0f };    GLfloat Diffuse[] = { 0.8f, 0.8f, 0.8f, 1.0f };    GLfloat Specular[] = { 0.2f, 0.2f, 0.2f, 1.0f };     GLfloat SpecularExp[] = { 50 };                GLfloat Emission[] = { 0.1f, 0.1f, 0.1f, 1.0f };  glMaterialfv(GL_FRONT, GL_AMBIENT, Ambient);  glMaterialfv(GL_FRONT, GL_DIFFUSE, Diffuse);  glMaterialfv(GL_FRONT, GL_SPECULAR, Specular);  glMaterialfv(GL_FRONT, GL_SHININESS, SpecularExp);  glMaterialfv(GL_FRONT, GL_EMISSION, Emission);  glMaterialfv(GL_BACK, GL_AMBIENT, Ambient);  glMaterialfv(GL_BACK, GL_DIFFUSE, Diffuse);  glMaterialfv(GL_BACK, GL_SPECULAR, Specular);  glMaterialfv(GL_BACK, GL_SHININESS, SpecularExp);  glMaterialfv(GL_BACK, GL_EMISSION, Emission);  glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);	  glEnable(GL_COLOR_MATERIAL);  GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };  glLightfv(GL_LIGHT0, GL_POSITION, light_position);  glEnable(GL_LIGHT0);  glEnable(GL_LIGHTING);  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);  glDepthFunc(GL_LEQUAL);  glEnable(GL_DEPTH_TEST);  glShadeModel(GL_FLAT);  glClearColor(0.0, 0.0, 0.0, 0.0);  glEnable(GL_CULL_FACE);  glCullFace(GL_BACK);  glEnable(GL_NORMALIZE);  glMatrixMode(GL_PROJECTION);  glLoadIdentity();  glFrustum(-0.004,0.004,-0.004,0.004,.01,1000.0);  glMatrixMode(GL_MODELVIEW);}void Viewer::Init(int* argc, char **argv) {   glutInit(argc,argv);   glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH | GLUT_MULTISAMPLE);   /* setup the size, position, and display mode for new windows */   glutInitWindowSize(width,height);   glutInitWindowPosition(0,0);      /* create and set up a window */   glutCreateWindow("GCOP");      InitViewerWindow();  glutReshapeFunc(g_viewer_reshape);  glutDisplayFunc(g_viewer_render);  glutKeyboardFunc(g_viewer_keyboard);  glutMouseFunc(g_viewer_mouse);  glutMotionFunc(g_viewer_motion);#ifdef HAVE_GLUI_H  //  GLUI_Master.set_glutIdleFunc( g_viewer_idle ); #else  glutIdleFunc(g_viewer_idle);#endif  /*  int submenu1;  submenu1 = glutCreateMenu(g_save_frames);  glutAddMenuEntry("Single Frames", 1);  glutAddMenuEntry("All Frames", 2);   glutAddSubMenu("Save", submenu1);  glutAttachMenu(GLUT_RIGHT_BUTTON);  */}void Viewer::SetColor(const float rgb[3]){  this->rgb[0] = rgb[0];  this->rgb[1] = rgb[1];  this->rgb[2] = rgb[2];  glClearColor(rgb[0], rgb[1], rgb[2], 0.0);}void g_save_frames(int i){  cout << i << endl;}void Viewer::Start(){  //  g_timer_func(100);  glutMainLoop();}void Viewer::Add(View& view){  pthread_mutex_lock(&this->mut);    views[view.id] = &view;  pthread_mutex_unlock(&this->mut);  }void Viewer::Remove(View& view){  pthread_mutex_lock(&this->mut);    views.erase(view.id);  pthread_mutex_unlock(&this->mut);}void Viewer::RenderViews(){  pthread_mutex_lock(&this->mut);  map<int,View*>::iterator vi;  if (saveFrames) {    saveFrames = 0;    cout << "Viewer::RenderViews: saving frames...";    cout.flush();    int i = 0;    while (1) {      DrawOrigin(this->aqobj);      bool save = false;      for (vi=views.begin(); vi != views.end(); ++vi) {        View *view = vi->second;        view->Lock();        save |= view->RenderFrame(i);  // returns false when done        view->Unlock();      }       if (save) {                             char buf[256];        sprintf(buf, "%s_%04d.ppm", frameName, i);        SaveImage(buf);          glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);         cout << ".";        cout.flush();          } else {        //        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        break;      }      ++i;    }    cout << "done!" << endl;  } else  if (animate) {    animate = 0;    cout << "Viewer::RenderViews: animating frames...";    cout.flush();    int i = 0;    while (1) {      DrawOrigin(this->aqobj);      //      glColor3f(0, 0, 1);      //      glutSolidCube(.4);      bool cont = false;      for (vi=views.begin(); vi != views.end(); ++vi) {        View *view = vi->second;        view->Lock();        cont |= view->RenderFrame(i);  // returns false when done        usleep(animDelay);        view->Unlock();      }       if (cont) {              usleep(animDelay);                       glFlush();        glutSwapBuffers();        cout << ".";        cout.flush();            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);       } else {        //        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);        break;      }      ++i;    }    cout << "done!" << endl;  } else {          // DrawOrigin(this->aqobj);        for (vi=views.begin(); vi != views.end(); ++vi) {      View *view = vi->second;      view->Lock();      view->Render();      view->Unlock();    }         if (saveDisplay || saveSnapshot) {      char buf[256];      sprintf(buf, "%s_%04d.ppm", displayName, displayNo++);      glFlush();      SaveImage(buf);        cout << ".";      cout.flush();      if (saveSnapshot) {        saveSnapshot = false;      }      //      glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);     }  }  /*  View* current = this->views;  while(current) {    current->Lock();    current->Render();    current->Unlock();    current = current->next;  }  */  pthread_mutex_unlock(&this->mut);}void Viewer::DrawText(const char *str, float size){  int len = strlen(str);  glPushMatrix();  for (int i = 0; i < len; ++i) {    int c = str[i];    int w = glutStrokeWidth(GLUT_STROKE_ROMAN, c);    float s = size/w;    glPushMatrix();    glScalef(s, s, s);    glutStrokeCharacter(GLUT_STROKE_ROMAN, c);    glPopMatrix();    glTranslatef(size, 0, 0);  }  glPopMatrix();}void Viewer::DrawCircle(double x, double y, double r, int slices){  assert(slices > 0);    double da = 2*M_PI/slices;  double a = 0;  glBegin(GL_LINE_LOOP);  for (int i = 0; i < slices; ++i, a += da)    glVertex2f(x + r*cos(a), y + r*sin(a));  glEnd();}void Viewer::DrawArrow(double l, GLUquadricObj *qobj){  if (!qobj) {    qobj = gluNewQuadric();    assert(qobj);    DrawArrow(l, qobj);    free(qobj);  }  glPushMatrix();  gluCylinder(qobj, .01, .01, l, 10, 10);  glTranslated(0,0,l);  gluCylinder(qobj, .02, 0, .1, 10, 10);  glPopMatrix();}void Viewer::DrawArrow(const double v[3], GLUquadricObj *qobj){  if (!qobj) {    qobj = gluNewQuadric();    assert(qobj);    DrawArrow(v, qobj);    free(qobj);  }  glPushMatrix();    double n = NORM3(v);    if (n < 1e-6) {    glPopMatrix();    return;  }  double e[3];  double z[3] = {0,0,1};  CROSS(e,z,v);  DIV3(e,e,n);  double a = acos(DOT3(z,v)/n);  glRotated(a/M_PI*180, e[0], e[1], e[2]);  gluCylinder(qobj, n/50, n/50, n, 10, 10);    glTranslated(0,0,n);  gluCylinder(qobj, n/25, 0, n/10, 10, 10);  glPopMatrix();}void Viewer::DrawOrigin(GLUquadricObj *aqobj){  glPushMatrix();  glScalef(os,os,os);  DrawFrame(aqobj);  glPopMatrix();  }void Viewer::DrawFrame(GLUquadricObj *aqobj){  glColor3f(0, 0, 1);  SetMaterial(0,0,1, 0,0,1, 0,0,1.0,50);  DrawArrow(1, aqobj);  glPushMatrix();  glColor3f(0, 1, 0);  SetMaterial(0,1,0, 0,1,0, 0,1,0,50);  glRotatef(-90, 1, 0, 0);  DrawArrow(1, aqobj);  glPopMatrix();  glPushMatrix();  glColor3f(1, 0, 0);  SetMaterial(1,0,0, 1,0,0, 1,0,0,50);  glRotatef(90, 0, 1, 0);  DrawArrow(1, aqobj);  glPopMatrix();}void Viewer::Reshape(int width, int height) {  this->width = width;  this->height = height;  this->aspect = (float)width/(float)height;  this->rgbimg = (unsigned char*)realloc(this->rgbimg, 4*width*height*sizeof(double));  this->ppmimg = (unsigned char*)realloc(this->ppmimg, 4*width*height*sizeof(double));    glViewport(0, 0, width, height);  //  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  //  glutPostRedisplay();}void Viewer::DrawAll(){  this->RenderViews();    glDisable(GL_TEXTURE_2D); //added this  glMatrixMode(GL_PROJECTION);  glPushMatrix();  glLoadIdentity();  gluOrtho2D(0.0, width, 0.0, height);  glMatrixMode(GL_MODELVIEW);  glPushMatrix();  glLoadIdentity();  glRasterPos2i(10, 20);  glLogicOp(GL_SET);    glColor3d(1.0, .0, .0);  glDisable(GL_LIGHTING);  string s = "a - animate | f - save frames | Esc - exit | Press and move to navigate/zoom";  void * font = GLUT_BITMAP_9_BY_15;  for (string::iterator i = s.begin(); i != s.end(); ++i)    {      char c = *i;      glutBitmapCharacter(font, c);    }  glEnable(GL_LIGHTING);  glMatrixMode(GL_PROJECTION); //swapped this with...  glPopMatrix();  glMatrixMode(GL_MODELVIEW); //...this  glPopMatrix();  //added this  glEnable(GL_TEXTURE_2D);      DrawOrigin(this->aqobj);}void Viewer::Render(){  //  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  /*  glLoadIdentity();   glTranslatef(0.0, 0.0, -(dis+ddis));  glRotated(elev+delev, 1.0, 0.0, 0.0);  glRotated(azim+dazim, 0.0, 1.0, 0.0);  glRotated(90.0,-1.0,0.0,0.0);  */      //glMatrixMode(GL_PROJECTION);  // glLoadIdentity();  //gluPerspective(64.0, this->aspect, this->zNear, this->zFar);  //gluPerspective(0, aspect, zNear, zFar);  // gluLookAt(0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);  // gluLookAt(1, -5, 5, 0, 1, -1, 0, 1, 1);    glMatrixMode(GL_MODELVIEW);  glLoadIdentity();  glTranslatef(this->sx, this->sy, this->sz);  glRotatef(-this->stheta, 1.0, 0.0, 0.0);  glRotatef(this->sphi, 0.0, 0.0, 1.0);  //  Viewer::SetMaterial(0.0,0.5,1.0,0.0,0.5,1.0,1.0,1.0,1.0,50);  //  glutSolidCube(.2);  this->DrawAll();  glFlush();  glutSwapBuffers();    // glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);}void Viewer::Keyboard(unsigned char ch, int x, int y) {  switch (ch) {   case 27:    exit(0);    break;  case 'f':    saveFrames = !saveFrames;    break;  case 'a':    animate = !animate;    break;  case 'd':    saveDisplay = !saveDisplay;    break;  case 's':    saveSnapshot = true;    break;  case 'c':    cout << "Camera: phi=" << sphi << " theta=" << stheta << " x=" << sx << " y=" << sy << " z=" << sz << endl;    break;  default:   return;  }  glutPostRedisplay();}void Viewer::Mouse(int button, int state, int x, int y) {  this->downX = x; this->downY = y;  this->leftButton = ((button == GLUT_LEFT_BUTTON) && (state == GLUT_DOWN));  this->middleButton = ((button == GLUT_MIDDLE_BUTTON) &&  (state == GLUT_DOWN));  this->rightButton = ((button == GLUT_RIGHT_BUTTON) &&  (state == GLUT_DOWN));  glutPostRedisplay();}void Viewer::Motion(int x, int y) {  double s = 2;  if (this->leftButton) {    this->sphi += (float)(x - this->downX)/4.0/s;    this->stheta += (float)(this->downY - y)/4.0/s;  }  if (this->middleButton) {    this->sz += (float)(-this->downY + y) / 10.0/s;    }  if (this->rightButton) {    this->sy += (float)(this->downY - y) / 10.0/s;      this->sx -= (float)(this->downX - x) / 10.0/s;    } // scale  this->downX = x;     this->downY = y;  glutPostRedisplay();}void Viewer::SaveImage(const char* name){  assert(this->rgbimg);  assert(this->ppmimg);    //  struct timeval timer;  //  timer_start(&timer);  //#define DGC_VIEWER_TEX#ifdef DGC_VIEWER_TEX  int texName;    glEnable(GL_TEXTURE_RECTANGLE_ARB);  glBindTexture(GL_TEXTURE_RECTANGLE_ARB, texName);    glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);  glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);  glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MAG_FILTER, GL_LINEAR);  glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_MIN_FILTER, GL_LINEAR);  //  glTexParameteri(GL_TEXTURE_RECTANGLE_ARB, GL_TEXTURE_STORAGE_HINT_ARB, GL_STORAGE_SHARED_ARB);    // initialize the texture  glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, rgbimg);    //glTexImage2D(GL_TEXTURE_RECTANGLE_ARB, 0, GL_RGBA, width, height, 0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, rgbimg);  glCopyTexSubImage2D( GL_TEXTURE_RECTANGLE_ARB, 0, 0, 0, 0, 0, width, height);  glFlush();    // glFlush initiates the AGP download and glGetTexImage will block for it to complete  // one can do other interesting work here in the meantime or use 2 textures and ping pong between them    //  glGetTexImage(GL_TEXTURE_RECTANGLE_ARB, 0, GL_BGRA, GL_UNSIGNED_INT_8_8_8_8_REV, rgbimg);  glGetTexImage(GL_TEXTURE_RECTANGLE_ARB, 0, GL_BGR, GL_UNSIGNED_BYTE, rgbimg);  glFlush();#else  glReadPixels(0, 0, width, height, GL_RGB, GL_UNSIGNED_BYTE, rgbimg);#endif    //   //  cout << "timer: " << timer_us(&timer) << "us." << endl;    FILE *fptr = 0;  if (!name) {    char buf[256];    sprintf(buf, "%s_%04d.ppm", displayName, displayNo++);    fptr = fopen(name, "w");  } else {    fptr = fopen(name, "w");  }  assert(fptr);    fprintf(fptr, "P6\n%d %d\n255\n", width, height);  for (int i = 0; i < height; ++i) {    memcpy(ppmimg + i*width*3,            rgbimg + (height-1-i)*width*3,            width*3*sizeof(char));  }  fwrite(ppmimg, height*width*3, 1, fptr);      fclose(fptr);}GLuint Viewer::LoadTexture(const char *fname, int wrap){  GLuint texture;  int width, height;  char* data;  FILE* file = fopen(fname, "r");  if (!file) {    fprintf(stderr, "Error - dem:dem_load - failed to open %s!\n", fname);    return 0;  }  int n = fscanf(file, "P6\n%d %d 255\n", &width, &height);    data = (char*)malloc( width * height * 3 );    // read texture data  n = fread( data, width * height * 3, 1, file );  fclose( file );    // allocate a texture name  glGenTextures( 1, &texture );    // select our current texture  glBindTexture( GL_TEXTURE_2D, texture );    // select modulate to mix texture with color for shading  //  glTexEnvf( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE );    // when texture area is small, bilinear filter the closest mipmap  glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,                   GL_LINEAR_MIPMAP_NEAREST );  // when texture area is large, bilinear filter the first mipmap  glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );    // if wrap is true, the texture wraps over at the edges (repeat)  //       ... false, the texture ends at the edges (clamp)  glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_S,                   wrap ? GL_REPEAT : GL_CLAMP );  glTexParameterf( GL_TEXTURE_2D, GL_TEXTURE_WRAP_T,                   wrap ? GL_REPEAT : GL_CLAMP );    // build our texture mipmaps  gluBuild2DMipmaps( GL_TEXTURE_2D, 3, width, height,                     GL_RGB, GL_UNSIGNED_BYTE, data );    // free buffer  free( data );  return texture;}void g_timer_func(int ms){  glutPostRedisplay();  glutTimerFunc(ms, g_timer_func, ms);}void g_viewer_reshape(int w, int h) {   assert(Viewer::instance != NULL);   Viewer::instance->Reshape(w, h); }void g_viewer_render() {   assert(Viewer::instance != NULL);    Viewer::instance->Render();}void g_viewer_keyboard(unsigned char ch, int x, int y) {   assert(Viewer::instance != NULL);   Viewer::instance->Keyboard(ch, x, y); }void g_viewer_mouse(int button, int state, int x, int y) {   assert(Viewer::instance != NULL);   Viewer::instance->Mouse(button, state, x, y); }void g_viewer_motion(int x, int y) {   assert(Viewer::instance != NULL);   Viewer::instance->Motion(x, y); }void g_viewer_idle(void){  usleep(60000);#ifdef HAVE_GLUI_H  if ( glutGetWindow() != Viewer::instance->window )     glutSetWindow(Viewer::instance->window);    GLUI_Master.sync_live_all();#endif  glutPostRedisplay(); }void Viewer::Cylinder(const double xa[3], const double xb[3],                       double r,int sd){  const double& x1 = xa[0];  const double& y1 = xa[1];  const double& z1 = xa[2];  const double& x2 = xb[0];  const double& y2 = xb[1];  const double& z2 = xb[2];  float vx = x2-x1;  float vy = y2-y1;  float vz = z2-z1;  //handle the degenerate case with an approximation  if(vz == 0)    vz = .00000001;  float v = sqrt( vx*vx + vy*vy + vz*vz );  float ax = 57.2957795*acos( vz/v );  if ( vz < 0.0 )    ax = -ax;  float rx = -vy*vz;  float ry = vx*vz;    GLUquadricObj *quadric=gluNewQuadric();  gluQuadricNormals(quadric, GLU_SMOOTH);    glPushMatrix();  glTranslatef( x1,y1,z1 );  glRotatef(ax, rx, ry, 0.0);  //draw the cylinder  gluCylinder(quadric, r, r, v, 32, 1);  gluQuadricOrientation(quadric,GLU_INSIDE);  //draw the first cap  gluDisk( quadric, 0.0, r, 32, 1);  glTranslatef( 0,0,v );  //draw the second cap  gluQuadricOrientation(quadric,GLU_OUTSIDE);  gluDisk( quadric, 0.0, r, 32, 1);  glPopMatrix();    gluDeleteQuadric(quadric);} void Viewer::RenderEllipsoid(const Matrix3d &P){  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);  glEnable(GL_BLEND);    glPushMatrix();  glColor3f(.8,0,0);  SelfAdjointEigenSolver<Matrix3d> eigensolver(P);  if (eigensolver.info() != Success) {    cout << "[W] RenderEllipsoid: cannot find eigen decomposition" << endl;    return;  }  Vector3d d=eigensolver.eigenvalues();  Matrix3d V=eigensolver.eigenvectors();    //  cout << "d = " << d.transpose() << " V=\n" << V << endl;  for (int k=0;k<3;++k) {    glBegin(GL_LINES);    glVertex3d(0,0,0);    Vector3d a =2*sqrt(d[k])*V.col(k);    glVertex3d(a[0], a[1], a[2]);    glEnd();  }  // glutSolidSphere(.2, 5, 5);  glColor4f(.5,.9,.9, .4);  Vector3d v;  SO3::Instance().log(v, V);  double n = v.norm();  if (n > 1e-6) {    v = SIGN(V.determinant())*v/n;    glRotated(RAD2DEG(n), v[0], v[1], v[2]);  }  glScaled(2*sqrt(d(0)), 2*sqrt(d(1)), 2*sqrt(d(2)));  //  glutSolidSphere(1, 50, 50);  glPopMatrix();  glDisable(GL_BLEND); }